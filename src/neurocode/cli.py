import argparse
import sys
from pathlib import Path

from .api import NeurocodeError, NeurocodeProject, open_project
from .check import check_file_from_disk
from .explain import explain_file_from_disk
from .query import QueryError, render_query_result, run_query
from .status import status_from_disk
from .toon_parse import load_repository_ir


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="neurocode",
        description=(
            "NeuroCode – Neural IR engine for structural understanding and "
            "reasoning over codebases."
        ),
    )
    from . import __version__

    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    # Phase 1 — Parsing & Graph
    ir_parser = subparsers.add_parser("ir", help="Generate IR for a repository")
    ir_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository (default: current directory)",
    )
    ir_parser.add_argument(
        "--check",
        action="store_true",
        help="Check existing IR freshness without rebuilding",
    )

    explain_parser = subparsers.add_parser(
        "explain", help="Explain a file using IR-informed reasoning"
    )
    explain_parser.add_argument("file", help="Python file to explain")
    explain_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    check_parser = subparsers.add_parser(
        "check", help="Run structural checks on a Python file"
    )
    check_parser.add_argument("file", help="Python file to check")
    check_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )
    check_parser.add_argument(
        "--status",
        action="store_true",
        help="Print a one-line machine-readable status (exit code still reflects severity)",
    )

    patch_parser = subparsers.add_parser(
        "patch", help="Apply an IR-informed patch to a Python file"
    )
    patch_parser.add_argument("file", help="Python file to patch")
    patch_parser.add_argument("--fix", help="High-level fix description")
    patch_parser.add_argument(
        "--plan",
        help="Path to a patch plan JSON generated by `neurocode plan-patch-llm`",
    )
    patch_parser.add_argument(
        "--strategy",
        choices=["guard", "todo", "inject"],
        default="guard",
        help=(
            "Patch strategy: guard inserts a None-check, todo inserts a TODO "
            "comment, inject adds a stub/log (default: guard)"
        ),
    )
    patch_parser.add_argument(
        "--inject-kind",
        choices=["notimplemented", "log"],
        default="notimplemented",
        help=(
            "When using --strategy inject, choose stub type: "
            "NotImplementedError or logging.debug (default: notimplemented)"
        ),
    )
    patch_parser.add_argument(
        "--inject-message",
        help="Override message used for inject strategy (defaults to --fix text)",
    )
    patch_parser.add_argument(
        "--target",
        help="Qualified or simple function name to patch (default: first module-level function)",
    )
    patch_parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not write changes; print the would-be patch summary instead",
    )
    patch_parser.add_argument(
        "--show-diff",
        action="store_true",
        help="After applying, print the unified diff of the change",
    )
    patch_parser.add_argument(
        "--require-fresh-ir",
        action="store_true",
        help="Fail if .neurocode/ir.toon is older than the target file",
    )
    patch_parser.add_argument(
        "--require-target",
        action="store_true",
        help="Fail instead of falling back if no target function can be selected",
    )
    patch_parser.add_argument(
        "--no-noop-note",
        action="store_true",
        help="Suppress note when patch was already present",
    )
    patch_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format for patch result (default: text)",
    )

    history_parser = subparsers.add_parser(
        "patch-history", help="Show applied patch history from .neurocode/patch-history.toon"
    )
    history_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository root (default: current directory)",
    )
    history_parser.add_argument(
        "--limit",
        type=int,
        default=20,
        help="Maximum number of entries to show (default: 20)",
    )
    history_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    status_parser = subparsers.add_parser("status", help="Report IR freshness and config summary")
    status_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository (default: current directory)",
    )
    status_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    query_parser = subparsers.add_parser(
        "query", help="Run structural queries against an existing IR"
    )
    query_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository root containing .neurocode/ir.toon (default: current directory)",
    )
    query_parser.add_argument(
        "--kind",
        required=True,
        choices=["callers", "callees", "fan-in", "fan-out"],
        help="Query kind to run",
    )
    query_parser.add_argument(
        "--symbol",
        help="Target function symbol (qualified name preferred) for callers/callees",
    )
    query_parser.add_argument(
        "--module",
        dest="module_filter",
        help="Restrict query scope to a module (name or path)",
    )
    query_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    embed_parser = subparsers.add_parser(
        "embed", help="Generate embeddings for the IR and write .neurocode/ir-embeddings.toon"
    )
    embed_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository root containing .neurocode/ir.toon (default: current directory)",
    )
    embed_parser.add_argument(
        "--provider",
        help="Embedding provider to use (e.g., openai, dummy)",
    )
    embed_parser.add_argument(
        "--model",
        help="Embedding model identifier (provider-specific)",
    )
    embed_parser.add_argument(
        "--update",
        action="store_true",
        help="Merge with existing .neurocode/ir-embeddings.toon if present",
    )
    embed_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    search_parser = subparsers.add_parser(
        "search", help="Semantic search over embeddings stored in .neurocode/ir-embeddings.toon"
    )
    search_parser.add_argument(
        "path",
        nargs="?",
        default=".",
        help="Path to the repository root containing .neurocode (default: current directory)",
    )
    query_group = search_parser.add_mutually_exclusive_group(required=True)
    query_group.add_argument(
        "--text",
        help="Text query to search for similar functions",
    )
    query_group.add_argument(
        "--like",
        help="Find functions similar to this symbol (e.g., package.module:func)",
    )
    search_parser.add_argument(
        "--k",
        type=int,
        default=10,
        help="Number of results to return (default: 10)",
    )
    search_parser.add_argument(
        "--module",
        dest="module_filter",
        help="Restrict results to a module/package (prefix match)",
    )
    search_parser.add_argument(
        "--provider",
        help="Embedding provider to use for text queries (e.g., openai, dummy)",
    )
    search_parser.add_argument(
        "--model",
        default=None,
        help="Expected embedding model; if set and differs from the store, search fails",
    )
    search_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="text",
        help="Output format (default: text)",
    )

    explain_llm_parser = subparsers.add_parser(
        "explain-llm", help="Build an LLM-ready reasoning bundle for a file/symbol"
    )
    explain_llm_parser.add_argument("file", help="Python file to explain for LLM consumption")
    explain_llm_parser.add_argument(
        "--symbol",
        help="Optional symbol (qualified function) to focus on, e.g., package.module:func",
    )
    explain_llm_parser.add_argument(
        "--k-neighbors",
        type=int,
        default=10,
        help="Number of semantic neighbors to include (default: 10)",
    )
    explain_llm_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="json",
        help="Output format (default: json)",
    )

    plan_patch_parser = subparsers.add_parser(
        "plan-patch-llm", help="Build an LLM-ready patch plan bundle for a file"
    )
    plan_patch_parser.add_argument("file", help="Python file to plan a patch for")
    plan_patch_parser.add_argument(
        "--fix",
        required=True,
        help="High-level description of the desired change",
    )
    plan_patch_parser.add_argument(
        "--symbol",
        help="Optional symbol (qualified function) to focus on, e.g., package.module:func",
    )
    plan_patch_parser.add_argument(
        "--k-neighbors",
        type=int,
        default=10,
        help="Number of semantic neighbors to include (default: 10)",
    )
    plan_patch_parser.add_argument(
        "--format",
        choices=["text", "json"],
        default="json",
        help="Output format (default: json)",
    )

    args = parser.parse_args()

    if args.command == "ir":
        repo_path = Path(args.path).resolve()
        if args.check:
            try:
                project = open_project(repo_path)
                stale = project.check_ir_freshness()
            except NeurocodeError as exc:
                print(f"[neurocode] error: {exc}", file=sys.stderr)
                sys.exit(1)
            if stale:
                print("[neurocode] IR is stale for modules:")
                for entry in stale:
                    print(f"  - {entry}")
                sys.exit(1)
            print("[neurocode] IR is fresh.")
            sys.exit(0)

        if not repo_path.exists() or not repo_path.is_dir():
            print(
                f"[neurocode] error: path does not exist or is not a directory: {repo_path}",
                file=sys.stderr,
            )
            sys.exit(1)
        try:
            project = NeurocodeProject(repo_path)
            result = project.build_ir(force=True)
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        print(
            "[neurocode] IR written to {path} (modules={modules}, functions={functions}, calls={calls})".format(
                path=result.ir_path,
                modules=result.modules,
                functions=result.functions,
                calls=result.calls,
            )
        )
    elif args.command == "explain":
        file_path = Path(args.file).resolve()
        try:
            output = explain_file_from_disk(file_path, output_format=args.format)
        except RuntimeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        print(output)
    elif args.command == "check":
        file_path = Path(args.file).resolve()
        try:
            output, exit_code, status = check_file_from_disk(
                file_path, output_format=args.format, return_status=True
            )
        except RuntimeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)

        print(output)
        if args.status:
            print(status)
        sys.exit(exit_code)
    elif args.command == "patch":
        file_path = Path(args.file).resolve()
        if not args.plan and (not args.fix or not args.fix.strip()):
            print("[neurocode] error: either --fix or --plan must be provided", file=sys.stderr)
            sys.exit(1)
        if args.plan and args.fix:
            print("[neurocode] error: --plan and --fix are mutually exclusive", file=sys.stderr)
            sys.exit(1)
        try:
            project = open_project(file_path)
            if args.plan:
                import json

                plan_data = json.loads(Path(args.plan).read_text(encoding="utf-8"))
                apply_result = project.apply_patch_plan(
                    plan_data,
                    dry_run=args.dry_run,
                    show_diff=args.show_diff,
                )
            else:
                apply_result = project.patch_file(
                    file_path,
                    fix=args.fix,
                    strategy=args.strategy,
                    target=args.target,
                    require_target=args.require_target,
                    dry_run=args.dry_run,
                    require_fresh_ir=args.require_fresh_ir,
                    inject_kind=args.inject_kind,
                    inject_message=args.inject_message,
                )
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)

        action = "Planned" if args.dry_run else "Applied"
        warnings_list: list[str] = list(apply_result.warnings or [])
        for warn in warnings_list:
            print(f"[neurocode] warning: {warn}", file=sys.stderr)

        if args.format == "json":
            import json

            payload = {
                "status": apply_result.status or ("noop" if apply_result.is_noop else "applied"),
                "file": str(apply_result.files_changed[0]),
                "target_function": apply_result.target_function,
                "summary": apply_result.summary or ("Patch plan applied" if args.plan else args.fix),
                "inserted_line": apply_result.inserted_line,
                "inserted_text": apply_result.inserted_text,
                "no_change": apply_result.is_noop,
                "warnings": warnings_list,
                "diff": apply_result.diff if (args.dry_run or args.show_diff) else None,
            }
            print(json.dumps(payload, indent=2))
        else:
            print(
                "[neurocode] {action} patch to {path}: {detail}".format(
                    action=action,
                    path=file_path,
                    detail=apply_result.summary or ("No changes" if apply_result.is_noop else "Applied"),
                )
            )
            if apply_result.is_noop and not args.no_noop_note:
                print("[neurocode] note: patch already existed; no change applied.")
            if (args.dry_run or args.show_diff) and apply_result.diff:
                print(apply_result.diff)
            if apply_result.is_noop and not args.dry_run:
                sys.exit(3)
    elif args.command == "patch-history":
        repo_path = Path(args.path).resolve()
        try:
            project = open_project(repo_path)
            entries = project.list_patch_history(limit=args.limit)
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)
        if args.format == "json":
            import json

            print(
                json.dumps(
                    [
                        {
                            "id": e.id,
                            "timestamp": e.timestamp,
                            "fix": e.fix,
                            "files_changed": e.files_changed,
                            "is_noop": e.is_noop,
                            "summary": e.summary,
                            "warnings": e.warnings,
                            "plan_id": e.plan_id,
                        }
                        for e in entries
                    ],
                    indent=2,
                )
            )
        else:
            if not entries:
                print("[neurocode] no patch history entries found")
            else:
                for e in entries:
                    files = ", ".join(e.files_changed)
                    warn = f" warnings={len(e.warnings)}" if e.warnings else ""
                    print(f"- {e.timestamp} {e.fix} files=[{files}] summary={e.summary}{warn}")
        sys.exit(0)
    elif args.command == "query":
        repo_path = Path(args.path).resolve()
        ir_file = repo_path / ".neurocode" / "ir.toon"
        if not ir_file.is_file():
            print(
                f"[neurocode] error: {ir_file} not found. Run `neurocode ir {repo_path}` first.",
                file=sys.stderr,
            )
            sys.exit(1)
        try:
            ir = load_repository_ir(ir_file)
            result = run_query(
                ir=ir,
                repo_root=repo_path,
                kind=args.kind,
                symbol=args.symbol,
                module_filter=args.module_filter,
            )
            output = render_query_result(result, output_format=args.format)
            print(output)
            sys.exit(0)
        except QueryError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)
    elif args.command == "embed":
        repo_path = Path(args.path).resolve()
        try:
            project = open_project(repo_path)
            project.ensure_embeddings(
                provider=args.provider,
                model=args.model,
                update=args.update,
            )
            emb_path = project.repo_root / ".neurocode" / "ir-embeddings.toon"
            if args.format == "json":
                import json

                payload = {
                    "path": str(emb_path),
                    "items": None,
                    "model": args.model,
                    "provider": args.provider,
                }
                print(json.dumps(payload, indent=2))
            else:
                print(
                    "[neurocode] embeddings written to {path} (model={model}, provider={provider})".format(
                        path=emb_path,
                        model=args.model,
                        provider=args.provider,
                    )
                )
            sys.exit(0)
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)
    elif args.command == "search":
        repo_path = Path(args.path).resolve()
        try:
            project = open_project(repo_path)
            if bool(args.text) == bool(args.like):
                raise NeurocodeError("Provide exactly one of --text or --like")
            results = project.search_code(
                text=args.text,
                like=args.like,
                module=args.module_filter,
                k=args.k,
                provider=args.provider,
                model=args.model,
            )
            query_type = "text" if args.text else "like"
            query_value = args.text or args.like
            if args.format == "json":
                import json

                payload = {
                    "query_type": query_type,
                    "query": query_value,
                    "k": args.k,
                    "results": [
                        {
                            "id": r.id,
                            "kind": r.kind,
                            "module": r.module,
                            "name": r.name,
                            "file": str(r.file),
                            "lineno": r.lineno,
                            "signature": r.signature,
                            "score": r.score,
                        }
                        for r in results
                    ],
                }
                print(json.dumps(payload, indent=2))
            else:
                header = f"[neurocode] search ({query_type}) k={args.k}"
                print(header)
                for r in results:
                    print(f"{r.score:.3f} {r.module}:{r.name} ({r.file}:{r.lineno}) {r.signature}")
            sys.exit(0)
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)
    elif args.command == "explain-llm":
        file_path = Path(args.file).resolve()
        try:
            project = open_project(file_path)
            bundle = project.explain_llm(
                file_path,
                symbol=args.symbol,
                k_neighbors=args.k_neighbors,
            )
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)

        if args.format == "json":
            import json

            print(json.dumps(bundle, indent=2))
        else:
            target = bundle.get("target")
            checks = bundle.get("checks", [])
            neighbors = bundle.get("semantic_neighbors", [])
            print(
                "[neurocode] explain-llm for {file} (module={module}, target={target})".format(
                    file=bundle.get("file"),
                    module=bundle.get("module"),
                    target=target["symbol"] if target else "(none)",
                )
            )
            print(
                "functions={fn} callers={c} callees={d} checks={chk} neighbors={n}".format(
                    fn=len(bundle.get("ir", {}).get("module_summary", {}).get("functions", [])),
                    c=len(bundle.get("call_graph", {}).get("callers", [])),
                    d=len(bundle.get("call_graph", {}).get("callees", [])),
                    chk=len(checks),
                    n=len(neighbors),
                )
            )
        sys.exit(0)
    elif args.command == "plan-patch-llm":
        file_path = Path(args.file).resolve()
        try:
            project = open_project(file_path)
            plan = project.plan_patch_llm(
                file_path,
                fix=args.fix,
                symbol=args.symbol,
                k_neighbors=args.k_neighbors,
            )
            bundle = plan.data
        except NeurocodeError as exc:
            print(f"[neurocode] error: {exc}", file=sys.stderr)
            sys.exit(1)
        except Exception as exc:  # pragma: no cover - defensive
            print(f"[neurocode] unexpected error: {exc}", file=sys.stderr)
            sys.exit(1)

        if args.format == "json":
            import json

            print(json.dumps(bundle, indent=2))
        else:
            ops = bundle.get("operations", [])
            target = bundle.get("target")
            print(
                "[neurocode] plan-patch-llm for {file} (module={module}, target={target})".format(
                    file=bundle.get("file"),
                    module=bundle.get("module"),
                    target=target["symbol"] if target else "(none)",
                )
            )
            print(f"fix: {bundle.get('fix')}")
            print(f"operations: {len(ops)}")
            for op in ops:
                print(f"- {op.get('id')}: {op.get('op')} @ {op.get('file')}:{op.get('lineno')}")
        sys.exit(0)
    elif args.command == "status":
        repo_path = Path(args.path).resolve()
        output, exit_code = status_from_disk(repo_path, output_format=args.format)
        print(output)
        sys.exit(exit_code)
    else:
        parser.error("Unknown command")


if __name__ == "__main__":
    main()
